const内存分配
const与#define最大的差别，Const在堆栈分配了空间，而#define只是把具体数值直接传递到目标变量罢了。或者说，const的常量是一个Run-Time的概念，他在程序中确确实实的存在可以被调用、传递。而#define常量则是一个Compile-Time概念，它的生命周期止于编译期：在实际程序中他只是一个常数、一个命令中的参数，没有实际的存在。
在C中，define常量是预处理阶段的工作，其不占据内存。但是const常量总是占据内存
在C++中，const常量是否占据存储空间取决于是否有引用该常量地址的代码。C++对于const默认为内部链接，因此const常量定义通常都放在头文件中，即使分配内存也不会出现链接错误。若不引用常量对应的地址，则不会为其分配空间。
Const是用来替换define的，因此其必须能够放在头文件中，在C++中const变量是默认为内部链接的，即在其他文件中看不到本文件定义的const变量，因此链接不会出现问题。Const变量在定义的时候必须初始化，除非显式的指定其为extern的。通常C++中会尽量避免为const变量分配内存storage的，而是在编译阶段将其保存在符号表symbol table中。当用extern修饰const变量或引用其地址时，将强制为其分配内存，因为extern表示采用外部链接，因此其必须有某个地址保存其值。
在c++我们知道一般是采用const来进行替代#define的。
-const常量存在于程序的数据段。
-#define常量存在于程序的代码段。
我们要把这个问题分不同的编译器来看。所以一般我们认为，Const常量是分配了内存空间的，而且只分配一次，在使用Const常量时与使用变量的引用方式一样，使用const常量还可以避免目标码的多份复制。在程序中，仅有一个内存来存放常量』但是根据编译器的不同，还略有不同。
在C编译下，Const常量是完全分配了内存空间的，在使用时，是像变量一样来使用的。参见以下实验代码。
C++编译器为了提高程序的执行效率，c++的编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高，这时Const常量是和#define常量一样的。如李san实验的结果一样『从汇编代码看，两种方法的汇编代码是相同的，所以目标码多份复制好像也不成立』。但是C++编译器对除了直接定义的Const常量外，都是分配内存的。所以，有以下来那个两种情况。
        extern const int N=3; 
使用了extern头,因为使用了extern我们将可能在外部文件使用N，而const默认的是内部链接，所以我们必须要为之分配内存的。
```
 #include<iostream>
    using namespace std; 
     const int M=3; 
    int main() 
    { 
    const   int *p=&M;//当编译器发现有对const定义的常量进行取地址操作时候会对M进行内存分配， 
                      //注意这个地址是const int*类型的，地址中的内容不可以改变的  
    int *pp=(int*)(&M)//此处我们将const int*类型强制转化成int * 但是对于*pp的任何赋值操作还是会报错的， 
                      //因为本质上的M是常量不可改变的，这也是const的优点  
        cout<<*p<<endl;   
      
        return 0;  
    } 
```
C语言中有时会出现类似这样的接口。
```
int getTitle(const char* buf, int len)
````
要求外面先分配内存，getTitle函数里面填充数据，之后外面再释放。应该分配多大内存呢？就先用null指针调用，getTitle(NULL, 0)会返回需要的内存大小。这样外面分配内存，外面释放，没有违背原则，但通常需要两次调用。
C++通常会使用RAII的手法，会将原始指针用类封装起来，返回一个智能指针。StringPtr getTitle(), 智能指针的释构函数会自动调用，就会将内存释放，而不用外面手动释放。这样也没有违背原则。
补充重要说明
·类内部的常量限制：使用这种类内部的初始化语法的时候，常量必须是被一个常量表达式初始化的整型或枚举类型，而且必须是static和const形式。
·如何初始化类内部的常量：一种方法就是static 和 const 并用，在外部初始化，例如：class A { public: A() {} private: static const int i; file://注意必须是静态的！ }；const int A::i=3;另一个很常见的方法就是初始化列表： class A { public: A(inti=0):test(i) {} private: const int i; }； 还有一种方式就是在外部初始化，
·如果在非const成员函数中，this指针只是一个类类型的；如果在const成员函数中，this指针是一个const类类型的；如果在volatile成员函数中,this指针就是一个volatile类类型的。
·new返回的指针必须是const类型的。
