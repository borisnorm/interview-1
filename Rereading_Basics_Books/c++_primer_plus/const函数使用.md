const在函数中也有很大的作用。
#函数中使用CONST
(1)const修饰函数参数
a.传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)
```
void function(const int Var);
```
b.参数指针所指内容为常量不可变
```
void function(const char* Var);
```
c.参数指针本身为常量不可变(也无意义，因为char* Var也是形参)
```
void function(char* const Var);
```
d.参数为引用，为了增加效率同时防止修改。修饰引用参数时：
```
void function(const Class& Var); //引用参数在函数内不可以改变

void function(const TYPE& Var); //引用参数在函数内为常量不可变
```
这样的一个const引用传递和最普通的函数按值传递的效果是一模一样的,他禁止对引用的对象的一切修改,唯一不同的是按值传递会先建立一个类对象的副本, 然后传递过去,而它直接传递地址,所以这种传递比按值传递更有效.另外只有引用的const传递可以传递一个临时对象,因为临时对象都是const属性, 且是不可见的,他短时间存在一个局部域中,所以不能使用指针,只有引用的const传递能够捕捉到这个家伙.


(2)const 修饰函数返回值
    const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。
```
    a.const int fun1() //这个其实无意义，因为参数返回本身就是赋值。
    b. const int * fun2() //调用时 const int *pValue = fun2();
                          //我们可以把fun2()看作成一个变量，即指针内容不可变。只能把该指针赋给const修饰的同类型指针变量。
    c.int* const fun3()   //调用时 int * const pValue = fun2();
                          //我们可以把fun2()看作成一个变量，即指针本身不可变。
```
一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回值为某个对象为const（const A test = A 实例）或某个对象的引用为const（const A& test = A实例） ，则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。
##4、类相关CONST

(1)const修饰成员变量
const修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值。在用const修饰类的成员属性的时候，const只是代表了只读属性，而不是一个常量。
```
    class A
    {
        …
        const int nValue;         //成员常量不能被修改
        …
        A(int x): nValue(x) { } ; //只能在初始化列表中赋值
     }
```

(2)const修饰成员函数
const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数。一般写在函数的最后来修饰。
```
    class A
    {
        …
       void function()const; //常成员函数, 它不改变对象的成员变量.

//也不能调用类中任何非const成员函数。
}
```
对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用。

a. const成员函数不被允许修改它所在对象的任何一个数据成员。

b. const成员函数能够访问对象的const成员，而其他成员函数不可以。
用const结尾的成员函数只能调用其他const结尾的成员函数。因为其他函数并不能保证同样不修改类的成员变量
成员函数后加const,表示：类作者提示你,这个函数不会导致对象状态改变
可以理解为"表示这个函数不会修改任何成员变量"
但不可绝对化。其实，还是可以修改由mutable关键字修饰的成员变量的。

 

(3)const修饰类对象/对象指针/对象引用

·             const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。

·             const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。
例如：
```
class AAA
{
    void func1();
void func2() const;
}
const AAA aObj;
aObj.func1(); ×
aObj.func2(); 正确

const AAA* aObj = new AAA();
aObj-> func1(); ×
aObj-> func2(); 正确
```
#三、将Const类型转化为非Const类型的方法
采用const_cast 进行转换。 
用法：const_cast <type_id>  (expression)
该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。

 

#四、使用const的一些建议
要大胆的使用const，这将给你带来无尽的益处，但前提是你必须搞清楚原委；
要避免最一般的赋值操作错误，如将const变量赋值，具体可见思考题；
在参数中使用const应该使用引用或指针，而不是一般的对象实例，原因同上；
const在成员函数中的三种用法（参数、返回值、函数）要很好的使用；
不要轻易的将函数的返回值类型定为const;
除了重载操作符外一般不要将返回值类型定为对某个对象的const引用;
任何不会修改数据成员的函数都应该声明为const 类型。

